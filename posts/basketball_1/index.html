<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Rich Bingham">
<meta name="description" content="Basketball has a lot of close games, but how often do good teams need to come from behind to win?">

<title>How Efficient is Basketball? – QSAY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/qsay_logo_q.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-fe60678887c101e8905ea43c0d230df2.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../images/qsay_logo.png" alt="QSAY" class="navbar-logo light-content">
    <img src="../../images/qsay_logo.png" alt="QSAY" class="navbar-logo dark-content">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../people/index.html"> 
<span class="menu-text">People</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications/index.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../news/index.html"> 
<span class="menu-text">News</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.youtube.com/@CorridorOfUncertainty"> 
<span class="menu-text">Corridor of Uncertainty</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#frequent-scoring-close-games" id="toc-frequent-scoring-close-games" class="nav-link active" data-scroll-target="#frequent-scoring-close-games">Frequent Scoring, Close Games</a></li>
  <li><a href="#dominating-games-last-minute-winners" id="toc-dominating-games-last-minute-winners" class="nav-link" data-scroll-target="#dominating-games-last-minute-winners">Dominating Games &amp; Last Minute Winners</a></li>
  <li><a href="#binomial-regression" id="toc-binomial-regression" class="nav-link" data-scroll-target="#binomial-regression">Binomial Regression</a></li>
  <li><a href="#dominating-but-not-winning-inefficient" id="toc-dominating-but-not-winning-inefficient" class="nav-link" data-scroll-target="#dominating-but-not-winning-inefficient">Dominating But Not Winning = Inefficient?</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">How Efficient is Basketball?</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Basketball</div>
    <div class="quarto-category">NBA</div>
  </div>
  </div>

<div>
  <div class="description">
    Basketball has a lot of close games, but how often do good teams need to come from behind to win?
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Rich Bingham </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">Feb 2022</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="frequent-scoring-close-games" class="level2">
<h2 class="anchored" data-anchor-id="frequent-scoring-close-games">Frequent Scoring, Close Games</h2>
<p>Basketball is one of the youngest widely played team sports in the world. Over its short history it has grown from its roots in the YMCA to global popularity, with even derivative forms being played as Olympic competition. There have been several developments that have reformed the game, such as the introduction of the shot clock, the three point line and liberalisation of the rules regarding dunking. A feature practically unique to basketball however is the common occurrence of high-scoring, but still close, games. In a game both teams often score more than 100 points each while the final winning margin will be less than 3 points, meaning that the outcome could have been reversed by one more scoring event. Between the 2016-17 and the 2024-25 season, both teams scored more than 100 in 65% of the 10,740 games played. 18% of these high-scoring games finished within 3 points. Last-gasp winners exist in many sports, but not many of these last-gasp winners are only the last of (on average) 116 equivalent events.</p>
<p>While similar scoring dynamics are present in games like tennis or badminton, in those sports the aim is to reach a certain point total, rather than scoring the most points within a given time period. Rugby matches can have the similar turnarounds, but the number of scoring events is much lower. Time-limited close games certainly lead to exciting contests.</p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/greStrG8iVA" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<p>This dynamic does suggest that the game is sometimes won by whichever team scores last. Given the rapid turnovers of possessions in a basketball game, could the outcome be a 50/50 coin toss? Obviously this is an oversimplification, as some teams can win games consistently, with the Golden State Warriors &amp; the Boston Celtics both consistently producing high winning percentages in recent years. In close games, the final seconds of game time can often be extended by breaks in play such as timeouts and the efficient use of this ‘clock control’ is often cited as a key factor in successful teams.</p>
<p>If basketball can often be decided by which team scores last, does the `best’ team always win the championship? Are the most successful teams rewarded with spots in the playoffs? Given that the ultimate aim is to reach the playoffs and win the championship, in some ways the answer to the last two questions is always yes. En route to the NBA finals in the 2024-25 season, the Indiana Pacers won three games in the playoffs where they trailed going into the final minute. The eastern conference semifinal against the Cleveland Cavaliers was particularly notable; the Pacers trailed from midway through the first quarter before finally regaining the lead with one second left in the game. While many sports have such exciting last-gasp reversals, the high-scoring nature of basketball raises the question, how often do teams dominate scoring while losing games? This in turn brings up a larger question, is basketball ‘efficient’? Is there an inherent nature of the games and competition structure that rewards dominating games less than expected? To address these questions we will need both game and season data.</p>
</section>
<section id="dominating-games-last-minute-winners" class="level2">
<h2 class="anchored" data-anchor-id="dominating-games-last-minute-winners">Dominating Games &amp; Last Minute Winners</h2>
<p>Each basketball game generates a wealth of data, much of which is publicly accessible in recent years. Play-by-play game logs can be insightful as these record all distinct actions in a game, such as fouls or scoring events. From these game logs we can reconstruct any derived statistics on a per-game basis. Below is the scoring differential of that eastern conference semifinal between Indiana and Cleveland.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We can see that Cleveland were ahead for the vast majority of the game, after a short period of Indiana leading at the start. The deciding part however came with only three seconds to go, when the Pacers’ point guard Haliburton launched a successful 3-pt shot turning a 117-119 loss into a 120-199 win. While the result is obviously decided by the score at the end of play, Indiana were only leading for 7% of the total game time, compared to 88% for Cleveland (the remaining ~5% the score was even) so were the Pacers really the ‘better’ team? 88% is a lot of the game to lead and still lose. Do successful teams avoid what happened to Cleveland? Do they regularly come from behind as Indiana did?</p>
<p>To look into these questions we will use the game logs from the 2016-17 to the 2024-25 seasons. This covers 11,534 games in total, including 10755 regular season games. We will focus on the regular season games to ensure all teams have a comparable number of games in the dataset. To see how out of the ordinary Cleveland’s loss was, we calculate the fraction each team spends ahead/behind in a game, classifying these by whether they win or lose. Below we see the distribution of how long teams which lose have spent leading games. There is obviously a large peak at 0 for very one-sided games, but we can see a long tail all the way up to nearly 100% - the longest a team has lead the game and lost in this period is Clippers vs Wizards from January 2022, where the Clippers first took the lead with less than two seconds remaining. We can now see that Cleveland’s failure to complete a dominant win was unusual - only 79 games of the 10,740 analysed (15 games were dropped due to incomplete data) had a team who had longer in the lead, but went on to lose. That’s 0.74%, meaning this game would be in the top 1% of dominant losses.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The time spent behind in a win is the mirror of this distribution, as expected. The reverse measure, the time spent leading in games won shows a similar distribution, although the peak at 99% is smaller - it’s harder to dominate games than lose them comprehensively. Time spent in a tie is not counted in either statistic, so 0% time in front in a loss could include long stretches of tied game.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Using these distributions of data from the 9 seasons analysed we could label certain games according to their position in the distribution. We have labelled losses from the top 10 percentile of losing time in front as “dominant defeats”, which indicates that the losing team spent at least 61.5% of the game leading, while we also label wins from the bottom 10 percentile of winning time in front (also 61.5%) as “unlikely wins”. The plots below show each teams unlikely winds and dominant defeats across the 9 seasons. Comparing these to win percentage, we can see that generally more successful teams do have more unlikely wins (filled circles) than dominant defeats (open circles), although it is far from a distinct trend and the overall number of these games is comparable between teams and seasons.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We have seen that the extreme cases of dominant defeats and unlikely wins aren’t strong indicators of a teams success, but how do the measures that defined these games work out over a season? Do the teams that led for the longest in games have the highest win percentage? We can examine the correlations to find out.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The average winning time (averaged per season for each team) in front has a positive correlation with win percentage as expected, given that winning teams will spend longer in front. The standard deviation of the winning time in front has negative correlation with the win percentage, meaning that winning teams more consistently dominate games. The losing time in front also has a positive (but weaker) correlation with the win percentage, as winning teams will still hold the lead in games they have lost. Interestingly, the standard deviation of the losing time in front has a positive correlation with the win percentage, which is caused by more successful teams having more losses where they lead for significant periods.</p>
<p>The measures we have considered so far are all continuous measures, but the outcomes that a team desires are all binary outcomes - you either win the championship or you don’t, make the postseason or don’t. We can compare how well the continuous variables predict binary outcomes using a technique called Binomial Regression.</p>
</section>
<section id="binomial-regression" class="level2">
<h2 class="anchored" data-anchor-id="binomial-regression">Binomial Regression</h2>
<p>Binomial Regression fits a logistic model (an S-shaped, sigmoidal curve) using the continuous explanatory variables to predict the binary response variable. This then yields a probability of the outcome for each value of the explanatory variable. We can see how this works using the win percentage to see how well this predicts the probability of a team making the postseason.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The points in this plot represent the final league win percentage of teams over the past 9 seasons, offset according to whether the team qualified for the postseason in that year. Points with a postseason prob at 1 made the postseason, while those at 0 missed out. Binomial Regression generates the grey curve which describes how we could predict a team’s postseason likelihood given its win percentage, based upon the previous seasons. The curve is fitted using two parameters; the ‘slope’ and the intercept. The intercept can be considered as the residual chance of making the playoffs when the team wins no games. In this case, the intercept is 2.4E-9, meaning a team winning no games has about a 1 in 400 million chance of making the postseason. The ‘slope’ is 1.5, which means that the odds ratio (given by p/(1-p)) of making the postseason increase by 1.5 for each percentage point increase in win percentage. We can also calculate that the tipping point at which making the postseason is more likely than not (i.e.&nbsp;50% probability) is a 48% win percentage. A win percentage above 54% gives a 90% chance of making the postseason. We can also determine how unlikely the outliers we see in this data are - the highest win percentage not to make the postseason belongs to the ’18 Denver Nuggets with 56%. This would normally give a 96% chance of making the postseason, equal to 26 to 1 in favour! The ’22 Spurs made the postseason with a winning percentage of 41%, which would normally give them a 5% chance, or 19 to 1 against. Qualification for the postseason in basketball depends on a teams position within the division rather than win percentage only, and these statistics highlight how the divisional system can be a mixed bag.</p>
<p>Reaching the postseason is obviously not the only outcome teams strive for each year, the playoffs have multiple stages, so we should consider how well win percentage predicts these outcomes. We can also compare them to the new measure of game dominance that we have derived, the average winning/losing time in front.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>As the teams progress further in the postseason, the model represented by the grey line is less confident in predicting success based upon the win percentage, which we can see as the logistic curve does not reach p=1 for the conference finals and beyond. A win percentage above 72% will give the team a 99% chance of making the conference semifinals, whereas a win percentage above 97% is required to give a similar level of confidence of a conference finals appearance. A win percentage above 77% is needed to give a ‘better than not’ (probability above 0.5) chance of making the NBA finals (above 78% is needed for the same level of confidence in an NBA title win). This has only been observed in six teams across the 9 years analysed, and three of those teams won the NBA title. Whereas each percentage point increase in win percentage increases a teams odds of making the postseason by 1.5, the odds of making the NBA finals only increase by 1.15. This means increasing the win percentage from 50% to 60% increases the odds of making the post season from 2 to 1 in favour to 133 to 1 in favour, but only shifts the odds of making the finals from 54 to 1 against to 12 to 1 against. At each stage we can use an ANOVA with a likelihood ratio test to determine if our model is appropriate for the data and significantly improves over the null hypotheses. All of the models used here meet this requirement.</p>
<p>We can replace win percentage with the average winning time in front to see how efficiently that works as a predictor of postseason success.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>From the spread of data, we can see that the model will be less confident in predicting success based on the average winning time in front, as many teams who have been very dominant in their wins fail to make the postseason. This is also seen in the progression though the playoffs, with the models predicting much lower probabilities of success for the higher average winning time in front for the later stages. To have a 99% chance of making the postseason, the model suggests that a team should lead (on average) for 90% of the games in which it wins. This level of dominant wins has not been seen in the 9 years analysed here. To get over a 50% chance of making the conference semifinals, a team should lead on average for 76% of the games in which they win. All the models for later rounds of the playoffs require much higher, unachievable, levels of dominance in order for the model to suggest a greater than 50% chance. The losing time in front is a less accurate predictor of postseason success.</p>
</section>
<section id="dominating-but-not-winning-inefficient" class="level2">
<h2 class="anchored" data-anchor-id="dominating-but-not-winning-inefficient">Dominating But Not Winning = Inefficient?</h2>
<p>Modelling with binomial regression shows that the win percentage of a team is a good predictor of reaching the postseason and a reasonable predictor of success within the postseason. This is to be expected, given that winning games is how a team achieves success. Analysis of the winning time in front shows that while it is correlated with win percentage, it is less effective at predicting how well a team will fair in the postseason. This is perhaps counter-intuitive, as we may expect that successful teams dominate games, spending the overwhelming majority of games in the lead, particularly given how frequent scoring is in basketball. Together this disconnect suggests that basketball is a very even sport, where even very successful teams will not be able to control most games, but rather ensure they win games by leading when it matters, at the end of the game. This does raise the possibility that basketball is not an efficient sport, where the teams who triumph at the end of the season are not necessarily the most dominant teams, although this unpredictability is often what fans relish in a sport.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>Graphs made with ggplot2 <span class="citation" data-cites="tidyverse">(<a href="#ref-tidyverse" role="doc-biblioref">Wickham et al. 2019</a>)</span> and gridExtra <span class="citation" data-cites="gridExtra">(<a href="#ref-gridExtra" role="doc-biblioref">Auguie 2017</a>)</span>. Data retrieved and analysed using hoopR <span class="citation" data-cites="hoopR">(<a href="#ref-hoopR" role="doc-biblioref">Gilani 2023</a>)</span>.</p>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-gridExtra" class="csl-entry" role="listitem">
Auguie, Baptiste. 2017. <em>gridExtra: Miscellaneous Functions for "Grid" Graphics</em>. <a href="https://doi.org/10.32614/CRAN.package.gridExtra">https://doi.org/10.32614/CRAN.package.gridExtra</a>.
</div>
<div id="ref-hoopR" class="csl-entry" role="listitem">
Gilani, Saiem. 2023. <em>hoopR: Access Men’s Basketball Play by Play Data</em>. <a href="https://CRAN.R-project.org/package=hoopR">https://CRAN.R-project.org/package=hoopR</a>.
</div>
<div id="ref-tidyverse" class="csl-entry" role="listitem">
Wickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain François, Garrett Grolemund, et al. 2019. <span>“Welcome to the <span class="nocase">tidyverse</span>.”</span> <em>Journal of Open Source Software</em> 4 (43): 1686. <a href="https://doi.org/10.21105/joss.01686">https://doi.org/10.21105/joss.01686</a>.
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/qsayork\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>2026 · Made with <img src="https://www.r-project.org/Rlogo.png" class="img-fluid" width="20"> and <a href="https://quarto.org/"><img src="https://quarto.org/quarto.png" class="img-fluid" alt="Quarto" width="65"></a></p>
</div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/qsayork/home">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>